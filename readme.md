

### Addition of Arbitrary-length Binary Numbers in C++

- input.txt  - two lines: numbers from 0 and 1  
- output.txt - the result
- tests
- ci
- linter 


### Roadmap:

- [x] `inputFile.seekg(0);`

- [x] переместить каретку на строку `inputLine` (нумеровать с нуля)

- [x] получить `length, inputZeros`

- [x] `arrSize = (length - inputZeros - 1) / WORD_BITS + 1;`

- [x] `arr = new word_t[arrSize];`
  
- [x] `zeros = WORD_BITS * arrSize - (length - inputZeros);`

- [x] выровнять ведущие нули

- [x] переписать строку в `arr`

- [ ] `C = A + B`

- [ ] `C.output()`

- [ ] ...


### todo-мысли: когда числа действительно произвольной длины, памяти не хватает

- числа могут быть действительно большие.  
  поэтому надо оценивать доступную память

- группируем бинарную строку по `WORD_BITS` и храним в массиве `word_t*` - поле `struct Number`

- будем считать, что для подсчета длины бинарной строки хватает `uint64_t`.  
  это условие почти не ограничивает максимальный вес одного числа:  
  `2^64 (Bit) / 2^43 (Bit / TB) = 2^21 (TB)`

- далее стоит понять, потребуется ли после вычисления суммы сохранять слагаемые.  
  от этого зависит, сколько потребуется памяти для *точного* вычисления `C = A + B`:  
  если `A, B` требуется сохранить: `2 * maxLength + minLength + 2` бит,  
  если `A, B` сохранить не требуется: `maxLength + minLength + 2` бит

- узнаём `length` и оцениваем память  

- если на точные вычисления памяти гарантированно не хватит:  
  записываем `A, B` в порядке `big endian` - считаем все оставшиеся цифры нулями, храним длину хвоста.
  получаем `C` приближенно в порядке `little endian`


### Изучить, повторить:

- [ ] https://lamagraph.github.io/intro-to-fpga-with-clash/

- [ ] OCaml базово

- [ ] Архитектура компьютера:
        процессор, различные виды памяти, шины (данных, команд), периферийные устройства, их подключение

- [ ] Архитектура процессора:
        триггеры, регистры, кэши, АЛУ, тактовый генератор 

- [ ] Представление данных: 
        байт, бит, машинное слово, целые, с плавающей точкой

- [ ] Целочисленная арифметика, битовые операции, переполнение
